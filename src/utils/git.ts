/**
 * Git integration utilities
 */

import { simpleGit, SimpleGit, CheckRepoActions } from 'simple-git';
import * as path from 'path';

export interface GitStatus {
  isRepository: boolean;
  hasChanges: boolean;
  hasUncommittedChanges: boolean;
  currentBranch?: string;
  commitHash?: string;
}

/**
 * Check git repository status
 */
export async function checkGitStatus(projectPath: string): Promise<GitStatus> {
  const git = simpleGit(projectPath);
  
  try {
    const isRepo = await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT);
    
    if (!isRepo) {
      return {
        isRepository: false,
        hasChanges: false,
        hasUncommittedChanges: false,
      };
    }

    const status = await git.status();
    const currentBranch = status.current || undefined;
    
    // Get latest commit hash
    let commitHash: string | undefined;
    try {
      const log = await git.log({ maxCount: 1 });
      commitHash = log.latest?.hash;
    } catch {
      // No commits yet
    }

    return {
      isRepository: true,
      hasChanges: status.files.length > 0,
      hasUncommittedChanges: status.files.some(f => f.index !== ' ' || f.working_dir !== ' '),
      currentBranch,
      commitHash,
    };
  } catch (error) {
    // If any git operation fails, assume it's not a proper git repo
    return {
      isRepository: false,
      hasChanges: false,
      hasUncommittedChanges: false,
    };
  }
}

/**
 * Initialize git repository if it doesn't exist
 */
export async function ensureGitRepository(projectPath: string): Promise<void> {
  const git = simpleGit(projectPath);
  
  const isRepo = await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT);
  if (!isRepo) {
    await git.init();
  }
}

/**
 * Add files to git staging area
 */
export async function addFilesToGit(projectPath: string, filePaths: string[]): Promise<void> {
  const git = simpleGit(projectPath);
  
  // Convert absolute paths to relative paths
  const relativePaths = filePaths.map(filePath => {
    if (path.isAbsolute(filePath)) {
      return path.relative(projectPath, filePath);
    }
    return filePath;
  });

  await git.add(relativePaths);
}

/**
 * Add all changes to git staging area
 */
export async function addAllChangesToGit(projectPath: string): Promise<void> {
  const git = simpleGit(projectPath);
  await git.add('.');
}

/**
 * Commit changes with a message
 */
export async function commitChanges(projectPath: string, message: string): Promise<string> {
  const git = simpleGit(projectPath);
  
  // Check if there are any changes to commit
  const status = await git.status();
  if (status.staged.length === 0) {
    // Auto-stage all changes if nothing is staged
    await git.add('.');
    const newStatus = await git.status();
    if (newStatus.staged.length === 0) {
      throw new Error('No changes to commit');
    }
  }

  const commit = await git.commit(message);
  return commit.commit;
}

/**
 * Create a git commit with all crow-agent changes
 */
export async function commitCrowAgentChanges(
  projectPath: string,
  changedFiles: string[],
  customMessage?: string
): Promise<string> {
  const git = simpleGit(projectPath);
  
  // Add specific files that were changed
  if (changedFiles.length > 0) {
    await addFilesToGit(projectPath, changedFiles);
  } else {
    // Fallback to adding all changes
    await addAllChangesToGit(projectPath);
  }

  const defaultMessage = `feat: add dark mode support via crow-agent

- Transform components with dark mode variants  
- Update Tailwind configuration to enable class-based dark mode
- Add ThemeToggle component for theme switching
- Ensure WCAG AA accessibility compliance

Generated by crow-agent`;

  const message = customMessage || defaultMessage;
  return await commitChanges(projectPath, message);
}

/**
 * Check if git user is configured
 */
export async function checkGitUserConfig(projectPath: string): Promise<{
  hasUser: boolean;
  hasEmail: boolean;
  user?: string;
  email?: string;
}> {
  const git = simpleGit(projectPath);
  
  try {
    const config = await git.getConfig('user.name');
    const user = config.value || undefined;
    
    const emailConfig = await git.getConfig('user.email');
    const email = emailConfig.value || undefined;
    
    return {
      hasUser: !!user,
      hasEmail: !!email,
      user,
      email,
    };
  } catch {
    return {
      hasUser: false,
      hasEmail: false,
    };
  }
}

/**
 * Configure git user if not set
 */
export async function configureGitUser(
  projectPath: string,
  user: string,
  email: string
): Promise<void> {
  const git = simpleGit(projectPath);
  
  await git.addConfig('user.name', user);
  await git.addConfig('user.email', email);
}

/**
 * Get git repository information
 */
export async function getGitInfo(projectPath: string): Promise<{
  isRepository: boolean;
  branch?: string;
  remotes: string[];
  lastCommit?: {
    hash: string;
    date: Date;
    message: string;
    author: string;
  };
}> {
  const git = simpleGit(projectPath);
  
  try {
    const isRepo = await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT);
    
    if (!isRepo) {
      return {
        isRepository: false,
        remotes: [],
      };
    }

    const status = await git.status();
    const remotes = await git.getRemotes();
    
    let lastCommit;
    try {
      const log = await git.log({ maxCount: 1 });
      if (log.latest) {
        lastCommit = {
          hash: log.latest.hash,
          date: new Date(log.latest.date),
          message: log.latest.message,
          author: log.latest.author_name,
        };
      }
    } catch {
      // No commits yet
    }

    return {
      isRepository: true,
      branch: status.current || undefined,
      remotes: remotes.map(r => r.name),
      lastCommit,
    };
  } catch (error) {
    return {
      isRepository: false,
      remotes: [],
    };
  }
}

/**
 * Create a backup branch before making changes
 */
export async function createBackupBranch(projectPath: string): Promise<string> {
  const git = simpleGit(projectPath);
  
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  const branchName = `crow-agent-backup-${timestamp}`;
  
  await git.checkoutLocalBranch(branchName);
  await git.checkout('-'); // Go back to previous branch
  
  return branchName;
}

/**
 * Check if there are uncommitted changes
 */
export async function hasUncommittedChanges(projectPath: string): Promise<boolean> {
  const git = simpleGit(projectPath);
  
  try {
    const status = await git.status();
    return status.files.length > 0;
  } catch {
    return false;
  }
}

/**
 * Get list of modified files
 */
export async function getModifiedFiles(projectPath: string): Promise<{
  staged: string[];
  unstaged: string[];
  untracked: string[];
}> {
  const git = simpleGit(projectPath);
  
  try {
    const status = await git.status();
    
    return {
      staged: status.staged,
      unstaged: status.modified.concat(status.deleted),
      untracked: status.not_added,
    };
  } catch {
    return {
      staged: [],
      unstaged: [],
      untracked: [],
    };
  }
}

/**
 * Stash current changes
 */
export async function stashChanges(projectPath: string, message?: string): Promise<void> {
  const git = simpleGit(projectPath);
  
  const stashMessage = message || `crow-agent stash ${new Date().toISOString()}`;
  await git.stash(['save', stashMessage]);
}

/**
 * Pop stashed changes
 */
export async function popStash(projectPath: string): Promise<void> {
  const git = simpleGit(projectPath);
  await git.stash(['pop']);
}
